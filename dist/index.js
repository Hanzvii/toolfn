"use strict";const r=t=>{if("[object Array]"!=Object.prototype.toString.call(t))throw new Error("typeErr: param must be Array");return[].concat(...t.map((t=>Array.isArray(t)?r(t):t)))},t=(r,e=1)=>{if("[object Array]"!=Object.prototype.toString.call(r))throw new Error("typeErr: first param must be Array");if("[object Number]"!=Object.prototype.toString.call(r))throw new Error("typeErr: second param must be Number");return r.reduce(((r,o)=>r.concat(e>1&&Array.isArray(o)?t(o,e-1):o)),[])};var e={all:(r,t=Boolean)=>{if("[object Array]"!=Object.prototype.toString.call(r))throw new Error("typeErr: first param must be Array");return r.every(t)},allEqual:r=>{if("[object Array]"!=Object.prototype.toString.call(r))throw new Error("typeErr: param must be Array");return r.every((t=>t===r[0]))},arrayToCSV:(r,t=",")=>{if("[object Array]"!=Object.prototype.toString.call(r))throw new Error("typeErr: first param must be Array");if("[object String]"!=Object.prototype.toString.call(t))throw new Error("typeErr: second param must be String");return r.map((r=>r.map((r=>`"${r}"`)).join(t))).join("\n")},averageBy:(r,t)=>{if("[object Array]"!=Object.prototype.toString.call(r))throw new Error("typeErr: first param must be Array");return t instanceof Function?r.map(t).reduce(((r,t)=>r+t),0)/r.length:r.map((r=>r[t])).reduce(((r,t)=>r+t),0)/r.length},bifurcate:(r,t)=>{if("[object Array]"!=Object.prototype.toString.call(r))throw new Error("typeErr: first param must be Array");return r.reduce(((r,e,o)=>(r[t[o]?0:1].push(e),r)),[[],[]])},castArray:r=>Array.isArray(r)?r:[r],compact:r=>{if("[object Array]"!=Object.prototype.toString.call(r))throw new Error("typeErr: param must be Array");return r.filter(Boolean)},countOccurrences:(r,t)=>{if("[object Array]"!=Object.prototype.toString.call(r))throw new Error("typeErr: first param must be Array");return r.reduce(((r,e)=>e===t?r+1:r),0)},deepFlatten:r,difference:(r,t)=>{if("[object Array]"!=Object.prototype.toString.call(r))throw new Error("typeErr: first param must be Array");if("[object Array]"!=Object.prototype.toString.call(t))throw new Error("typeErr: second param must be Array");const e=new Set(t);return r.filter((r=>!e.has(r)))},differenceBy:(r,t,e)=>{if("[object Array]"!=Object.prototype.toString.call(r))throw new Error("typeErr: first param must be Array");if("[object Array]"!=Object.prototype.toString.call(t))throw new Error("typeErr: second param must be Array");const o=new Set(t.map(e));return r.filter((r=>!o.has(e(r))))},dropWhile:(r,t)=>{if("[object Array]"!=Object.prototype.toString.call(r))throw new Error("typeErr: first param must be Array");for(;r.length>0&&!t(r[0]);)r=r.slice(1);return r},flatten:t,indexOfAll:(r,t)=>{if("[object Array]"!=Object.prototype.toString.call(r))throw new Error("typeErr: first param must be Array");return r.reduce(((r,e,o)=>e===t?[...r,o]:r),[])},intersection:(r,t)=>{if("[object Array]"!=Object.prototype.toString.call(r))throw new Error("typeErr: first param must be Array");if("[object Array]"!=Object.prototype.toString.call(t))throw new Error("typeErr: second param must be Array");const e=new Set(t);return r.filter((r=>e.has(r)))},intersectionBy:(r,t,e)=>{if("[object Array]"!=Object.prototype.toString.call(r))throw new Error("typeErr: first param must be Array");if("[object Array]"!=Object.prototype.toString.call(t))throw new Error("typeErr: second param must be Array");const o=new Set(t.map(e));return r.filter((r=>o.has(e(r))))},intersectionWith:(r,t,e)=>{if("[object Array]"!=Object.prototype.toString.call(r))throw new Error("typeErr: first param must be Array");if("[object Array]"!=Object.prototype.toString.call(t))throw new Error("typeErr: second param must be Array");if("[object Function]"!=Object.prototype.toString.call(e))throw new Error("typeErr: second param must be Function");return r.filter((r=>-1!==t.findIndex((t=>e(r,t)))))},randomIntArrayInRange:(r,t,e=1)=>{if("[object Number]"!=Object.prototype.toString.call(r))throw new Error("typeErr: first param must be Number");if("[object Number]"!=Object.prototype.toString.call(t))throw new Error("typeErr: second param must be Number");if("[object Number]"!=Object.prototype.toString.call(e))throw new Error("typeErr: third param must be Number");return Array.from({length:e},(()=>Math.floor(Math.random()*(t-r+1))+r))},sample:r=>{if("[object Array]"!=Object.prototype.toString.call(r))throw new Error("typeErr: param must be Array");return r[Math.floor(Math.random()*r.length)]},sampleSize:(r,t=1)=>{if("[object Array]"!=Object.prototype.toString.call(r))throw new Error("typeErr: first param must be Array");if("[object Number]"!=Object.prototype.toString.call(t))throw new Error("typeErr: second param must be Number");let e=r.length;for(;e;){const t=Math.floor(Math.random()*e--);[r[e],r[t]]=[r[t],r[e]]}return r.slice(0,t)},shuffle:r=>{if("[object Array]"!=Object.prototype.toString.call(r))throw new Error("typeErr: param must be Array");let t=r.length;for(;t;){const e=Math.floor(Math.random()*t--);[r[t],r[e]]=[r[e],r[t]]}return r},minN:(r,t=1)=>[...r].sort(((r,t)=>r-t)).slice(0,t)};let o=Object.assign(e);module.exports=o;
